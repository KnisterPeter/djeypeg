// -----------------------------------------------------------------------------
// 
// The JPEG grammar
// 
// -----------------------------------------------------------------------------
// 
// This is the main entry point into the JPEG grammar.
// 
JPEG :
  (rules+=Rule | Comment WS*)+ EOI
;

// -----------------------------------------------------------------------------

Rule :
  name=ID WS* returns=RuleReturns? WS* ':' WS* body=Body WS* ';' WS*
;

RuleReturns :
  'returns' WS* name=FQTN
;

// -----------------------------------------------------------------------------

Body :
  (expressions+=ChoiceExpression WS*)+
;

// -----------------------------------------------------------------------------
//
// Just syntactic common base class definition

Expression :
    ActionExpression
  | AndPredicateExpression
  | AnyCharExpression
  | AssignableExpression
  | AtomicExpression
  | ChoiceExpression
  | EndOfInputExpression
  | NotPredicateExpression
  | OneOrMoreExpression
  | OptionalExpression
  | RangeExpression
  | RuleReferenceExpression
  | SequenceExpression
  | SubExpression
  | TerminalExpression
  | ZeroOrMoreExpression
;

// -----------------------------------------------------------------------------

ChoiceExpression :
  choices+=SequenceExpression ('|' WS* choices+=SequenceExpression)*
;

// -----------------------------------------------------------------------------

SequenceExpression :
  (
    expressions+=
    (
        ActionExpression
      | AndPredicateExpression
      | NotPredicateExpression
      | OneOrMoreExpression
      | ZeroOrMoreExpression
      | OptionalExpression
      | AtomicExpression
    )
    WS*
  )+
;

// -----------------------------------------------------------------------------

ActionExpression :
  '{' WS* 
  ( property=ID WS* op=AssignmentOperator WS* 'current' WS*
  | name=FQTN
  ) 
  WS* '}'
;

// -----------------------------------------------------------------------------

AndPredicateExpression :
  '&' WS* expr=AtomicExpression
;

// -----------------------------------------------------------------------------

NotPredicateExpression :
  '!' WS* expr=AtomicExpression
;

// -----------------------------------------------------------------------------

OneOrMoreExpression :
  expr=AtomicExpression WS* '+'
;

// -----------------------------------------------------------------------------

ZeroOrMoreExpression :
  expr=AtomicExpression WS* '*'
;

// -----------------------------------------------------------------------------

OptionalExpression :
  expr=AtomicExpression WS* '?'
;

// -----------------------------------------------------------------------------

AtomicExpression :
    EndOfInputExpression
  | AssignableExpression
;

// -----------------------------------------------------------------------------

AssignableExpression :
  (property=ID WS* op=AssignmentOperator WS*)?
  expr=
  ( SubExpression
  | RangeExpression
  | TerminalExpression
  | AnyCharExpression
  | RuleReferenceExpression
  )
;

// -----------------------------------------------------------------------------

AssignmentOperator :
    single='=' 
  | multi='+='
;

// -----------------------------------------------------------------------------

SubExpression :
  '(' WS* expr=ChoiceExpression WS* ')'
;

// -----------------------------------------------------------------------------

RangeExpression : 
  '[' dash='-'? (!']' ranges+=(MinMaxRange | CharRange))* ']'
;

MinMaxRange returns Range :
  !'-' min=. '-' !'-' max=.
;

CharRange returns Range :
  !'-' char=.
;

// -----------------------------------------------------------------------------

AnyCharExpression :
  char='.'
;

// -----------------------------------------------------------------------------

RuleReferenceExpression :
  name=ID
;

// -----------------------------------------------------------------------------

EndOfInputExpression :
  'EOI'
;

// -----------------------------------------------------------------------------

TerminalExpression :
  '\'' value=InTerminalChar? '\''
;

InTerminalChar returns String :
  ('\\' '\'' | '\\' '\\' | !'\'' .)+
;

// -----------------------------------------------------------------------------

Comment :
  '//' (!('\r'? '\n') .)*
;

// -----------------------------------------------------------------------------

// 
// Namespaced type identifier
// 
FQTN returns String :
  ID ('.' ID)*
;

// 
// An ID name must start with an letter or underscore and be followed
// by letters, digits or underscores.
// 
ID returns String :
  [a-zA-Z_]([a-zA-Z0-9_])*
;

WS : 
  char=(' ' | '\n' | '\t' | '\r')
;

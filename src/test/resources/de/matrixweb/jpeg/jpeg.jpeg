// -----------------------------------------------------------------------------
// 
// The JPEG grammar
// 
// -----------------------------------------------------------------------------
// 
// This is the main entry point into the JPEG grammar.
// 
JPEG :
  (rules+=Rule | Comment WS*)+ EOI
;

// -----------------------------------------------------------------------------

Rule :
  name=ID WS* returns=RuleReturns? WS* ':' WS* body=Body WS* ';' WS*
;

RuleReturns :
  'returns' WS* name=FQTN
;

// -----------------------------------------------------------------------------

Body :
  (expressions+=ChoiceExpression WS*)+
;

// -----------------------------------------------------------------------------

ChoiceExpression returns Expression :
  choices+=SequenceExpression ('|' WS* choices+=SequenceExpression)*
;

// -----------------------------------------------------------------------------

SequenceExpression returns Expression :
  (
    expressions+=
    (
        ActionExpression
      | AndPredicateExpression
      | NotPredicateExpression
      | OneOrMoreExpression
      | ZeroOrMoreExpression
      | OptionalExpression
      | AtomicExpression
    )
    WS*
  )+
;

// -----------------------------------------------------------------------------

ActionExpression returns Expression :
  '{'
  WS* 
  ( 
      property=ID WS* op=AssignmentOperator WS* 'current' WS*
    | name=FQTN
  ) 
  WS* 
  '}'
;

// -----------------------------------------------------------------------------

AndPredicateExpression returns Expression :
  '&' WS* expr=AtomicExpression
;

// -----------------------------------------------------------------------------

NotPredicateExpression returns Expression :
  '!' WS* expr=AtomicExpression
;

// -----------------------------------------------------------------------------

OneOrMoreExpression returns Expression :
  expr=AtomicExpression WS* '+'
;

// -----------------------------------------------------------------------------

ZeroOrMoreExpression returns Expression :
  expr=AtomicExpression WS* '*'
;

// -----------------------------------------------------------------------------

OptionalExpression returns Expression :
  expr=AtomicExpression WS* '?'
;

// -----------------------------------------------------------------------------

AtomicExpression returns Expression :
    EndOfInputExpression
  | AssignableExpression
;

// -----------------------------------------------------------------------------

AssignableExpression returns Expression :
  (property=ID WS* op=AssignmentOperator WS*)?
  expr=
  ( SubExpression
  | RangeExpression
  | TerminalExpression
  | AnyCharExpression
  | RuleReferenceExpression
  )
;

// -----------------------------------------------------------------------------

AssignmentOperator :
    single='=' 
  | multi='+='
;

// -----------------------------------------------------------------------------

SubExpression returns Expression :
  '(' WS* expr=ChoiceExpression WS* ')'
;

// -----------------------------------------------------------------------------

RangeExpression : 
  '[' dash='-'? (!']' ranges+=(MinMaxRange | CharRange))* ']'
;

MinMaxRange returns Range :
  !'-' min=. '-' !'-' max=.
;

CharRange returns Range :
  !'-' char=.
;

// -----------------------------------------------------------------------------

AnyCharExpression returns Expression :
  char='.'
;

// -----------------------------------------------------------------------------

RuleReferenceExpression returns Expression :
  name=ID
;

// -----------------------------------------------------------------------------

EndOfInputExpression :
  'EOI'
;

// -----------------------------------------------------------------------------

TerminalExpression returns Expression :
  '\'' value=InTerminalChar? '\''
;

InTerminalChar returns String :
  ('\\' '\'' | '\\' '\\' | !'\'' .)+
;

// -----------------------------------------------------------------------------

Comment :
  '//' (!('\r'? '\n') .)*
;

// -----------------------------------------------------------------------------

// 
// Namespaced type identifier
// 
FQTN returns String :
  ID ('.' ID)*
;

// 
// An ID name must start with an letter or underscore and be followed
// by letters, digits or underscores.
// 
ID returns String :
  [a-zA-Z_]([a-zA-Z0-9_])*
;

WS : ' ' | '\n' | '\t' | '\r';

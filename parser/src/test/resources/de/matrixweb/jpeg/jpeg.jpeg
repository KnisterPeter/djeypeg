// -----------------------------------------------------------------------------
// 
// The JPEG grammar
// 
// -----------------------------------------------------------------------------
// 
// This is the main entry point into the JPEG grammar.
// 
Jpeg :
  (rules+=Rule | Comment WS*)+ EOI
;

// -----------------------------------------------------------------------------

Rule :
  name=ID WS* returns=RuleReturns? WS* ':' WS* body=Body WS* ';' WS*
;

RuleReturns :
  'returns' WS* name=FQTN
;

// -----------------------------------------------------------------------------

Body :
  (expressions+=ChoiceExpression WS*)+
;

// -----------------------------------------------------------------------------
//
// Just syntactic common base class definition

Expression :
    ActionExpression
  | AndPredicateExpression
  | AnyCharExpression
  | AtomicExpression
  | ChoiceExpression
  | NotPredicateExpression
  | OneOrMoreExpression
  | OptionalExpression
  | RangeExpression
  | RuleReferenceExpression
  | SequenceExpression
  | SubExpression
  | TerminalExpression
  | ZeroOrMoreExpression
;

// -----------------------------------------------------------------------------

ChoiceExpression returns Expression :
  choices+=SequenceExpression ('|' WS* choices+=SequenceExpression)*
;

// -----------------------------------------------------------------------------

SequenceExpression returns Expression :
  (
    expressions+=
    (
        ActionExpression
      | AndPredicateExpression
      | NotPredicateExpression
      | OneOrMoreExpression
      | ZeroOrMoreExpression
      | OptionalExpression
      | AtomicExpression
    )
    WS*
  )+
;

// -----------------------------------------------------------------------------

ActionExpression returns Expression :
  '{' WS* 
  ( property=ID WS* op=AssignmentOperator WS* 'current' WS*
  | name=FQTN
  ) 
  WS* '}'
;

// -----------------------------------------------------------------------------

AndPredicateExpression returns Expression :
  '&' WS* expr=AtomicExpression
;

// -----------------------------------------------------------------------------

NotPredicateExpression returns Expression :
  '!' WS* expr=AtomicExpression
;

// -----------------------------------------------------------------------------

OneOrMoreExpression returns Expression :
  expr=AtomicExpression WS* '+'
;

// -----------------------------------------------------------------------------

ZeroOrMoreExpression returns Expression :
  expr=AtomicExpression WS* '*'
;

// -----------------------------------------------------------------------------

OptionalExpression returns Expression :
  expr=AtomicExpression WS* '?'
;

// -----------------------------------------------------------------------------

AtomicExpression returns Expression :
    EndOfInputExpression
  | AssignableExpression
;

// -----------------------------------------------------------------------------

AssignableExpression returns AtomicExpression :
  (property=ID WS* op=AssignmentOperator WS*)?
  expr=
  ( SubExpression
  | RangeExpression
  | TerminalExpression
  | AnyCharExpression
  | RuleReferenceExpression
  )
;

// -----------------------------------------------------------------------------

AssignmentOperator :
    single='=' 
  | multi='+='
;

// -----------------------------------------------------------------------------

SubExpression returns Expression :
  '(' WS* expr=ChoiceExpression WS* ')'
;

// -----------------------------------------------------------------------------

RangeExpression returns Expression : 
  '[' dash='-'? (!']' ranges+=(MinMaxRange | CharRange))* ']'
;

MinMaxRange:
  !'-' min=. '-' !'-' max=.
;

CharRange:
  !'-' char=.
;

// -----------------------------------------------------------------------------

AnyCharExpression returns Expression :
  char='.'
;

// -----------------------------------------------------------------------------

RuleReferenceExpression returns Expression :
  name=ID
;

// -----------------------------------------------------------------------------

EndOfInputExpression returns AtomicExpression :
  'EOI'
;

// -----------------------------------------------------------------------------

TerminalExpression returns Expression :
  '\'' value=InTerminalChar? '\''
;

InTerminalChar:
  ('\\' '\'' | '\\' '\\' | !'\'' .)+
;

// -----------------------------------------------------------------------------

Comment :
  '//' (!('\r'? '\n') .)*
;

// -----------------------------------------------------------------------------

// 
// Namespaced type identifier
// 
FQTN:
  ID ('.' ID)*
;

// 
// An ID name must start with an letter or underscore and be followed
// by letters, digits or underscores.
// 
ID:
  [a-zA-Z_] [a-zA-Z0-9_]*
;

WS : 
  ' ' | '\n' | '\t' | '\r'
;
